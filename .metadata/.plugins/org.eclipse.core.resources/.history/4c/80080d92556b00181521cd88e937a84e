package abm.agents;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;

import abm.Calibrable;
import abm.Controller;
import abm.components.JobOffering;
import abm.components.NewMachine;
import abm.helpers.Utils;
import cern.jet.random.Binomial;
import cern.jet.random.Empirical;
import cern.jet.random.EmpiricalWalker;
import repast.simphony.random.RandomHelper;
import repast.simphony.util.collections.IndexedIterable;

public class CapitalGoodsFirm extends Firm {
	
	private ArrayList<NewMachine> catalog ;
	private double rd = 0 ;
	
	private double upsilon =  0.5 ;
	
	public CapitalGoodsFirm(double income, double debt, double assets, int nEmployees) {
		super(income, debt, assets, nEmployees);
		this.catalog = new ArrayList<NewMachine>();
		calculateRD();
	}
	
	public ArrayList<NewMachine> getCatalog() {
		return catalog;
	}
	
	@Override
	public void planProduction() {
		
		super.planProduction();
		
		double oldRD = this.rd ;
		
		calculateRD();
		
		double diff = this.rd - oldRD ;
		
		if(diff > 0) {
			createJobOfferings(diff);
		} else if(diff < 0) {
			fireWorkers(-diff);
		} else {
			// nothing changes
		}
	}
	
	private void calculateRD() {
		this.rd = this.upsilon * this.income ;
	}
	
	private void createJobOfferings(double additionalRD) {
		
		ArrayList<EmployedConsumer> workers = laborMarket.getAdjacent(this) ;
		int limit = workers.size() - 1;
		
		while(additionalRD > 0) {
			int inx = RandomHelper.nextIntFromTo(0, limit);
			double wage = workers.get(inx).getWage();
			addJobOffering(new JobOffering(wage));
			additionalRD -= wage ;
		}
	}
	
	public void fireWorkers(double excessRD) {
		
		ArrayList<EmployedConsumer> workers = laborMarket.getAdjacent(this) ;
		
		while(excessRD > 0 && workers.size() > 0) {
			int inx = RandomHelper.nextIntFromTo(0, workers.size() - 1);
			EmployedConsumer worker = workers.get(inx) ;
			double wage = worker.getWage();
			fire(worker);
			workers.remove(inx) ;
			excessRD -= wage ;
			this.additionalPayroll -= wage ;
		}
	}
	
	public void sellMachine(NewMachine machine, ConsumptionGoodsFirm firm) {

		if(catalog.contains(machine)) {
			machine.increaseUnits(1);
			this.income += machine.getPrice() ;
			creditMarket.executeTransaction(this, firm, machine.getPrice());
		}
	}
	
	public void innovate() {
		
		// TODO Verificar ordem adequada do expoente
		double prob = 1 - Math.exp(-Calibrable.getInnExponent()*this.rd);
		int inn = 1 ;
		
		if(prob != 1) {
			Binomial binon = RandomHelper.createBinomial(1, prob) ;
			inn = binon.nextInt() ;
		}

		if(inn == 1) {
			
		}
	}
	
	private EmpiricalWalker getSelectionFunction() {
		
		IndexedIterable<Agent> firms = Controller.getContext().getObjects(ConsumptionGoodsFirm.class);
		Iterator<Agent> itr = firms.iterator() ;
		
		double sum = 0 ;
		double disp = Calibrable.getInformationDispersion() ;
		
		while(itr.hasNext()) {
			
			ConsumptionGoodsFirm firm = (ConsumptionGoodsFirm) itr.next() ;
			
			double price = firm.getPrice() ;
			sum += Math.exp(-price/disp);
		}
		
		double[] probs = new double[firms.size()];
		
		for(int i = 0; i < firms.size(); i++) {
			
			double price = ((ConsumptionGoodsFirm) firms.get(i)).getPrice();
			probs[i] = Math.exp(-price/disp)/sum;
		}
		
		return RandomHelper.createEmpiricalWalker(probs, Empirical.NO_INTERPOLATION);
	}
	
	
	public void addMachine(NewMachine machine) {
		
		if(!catalog.contains(machine)) {
			catalog.add(machine);
			Collections.sort(catalog);
		}	
	}
	
	public double getRd() {
		return rd;
	}

	@Override 
	public String toString() {
		
		String strAgent = super.toString() ;
		Integer nMacs = this.catalog.size() ;
		String[][] fields = { { "Number of Machines", nMacs.toString()} } ;
		
	    return strAgent + Utils.getAgentDescriptor(fields, false) ;
	}


}
