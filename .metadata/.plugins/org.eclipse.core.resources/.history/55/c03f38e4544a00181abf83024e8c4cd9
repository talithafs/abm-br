package abm.agents;

import java.util.ArrayList;
import java.util.TreeSet;

import abm.helpers.Utils;
import repast.simphony.context.Context;
import repast.simphony.space.graph.Network;
import repast.simphony.util.ContextUtils;

public class ConsumptionGoodsFirm extends Firm {
	
	private TreeSet<UsedMachine> machines ;
	private ArrayList<Integer> demand ;
	private ArrayList<Integer> production ;
	
	private float beta = (float) 0.1 ;
	private float kappa = (float) 0.001 ;
	
	private int installedCap = 0;
	private int usedCap = 0;
	private int inventory = 0 ;
	private float price = -1;
	
	private int eDemand = 0 ;
	private int dProduction = 0 ;
	
	public ConsumptionGoodsFirm(float income, float debt, int nEmployees) {
		super(income, debt, nEmployees);
		this.machines = new TreeSet<UsedMachine>();
	}
	
	public TreeSet<UsedMachine> getMachines(){
		return machines ;
	}

	public int getInstalledCapacity() {
		return installedCap;
	}

	public int getUsedCapacity() {
		return usedCap;
	}

	public void updateCapacity() {
		
		int icap = 0 ;
		int ucap = 0 ;
		
		for(UsedMachine machine : this.machines) {
			icap += machine.getCapacity() ;
			ucap += machine.getUsedCapacity();
		}
		
		this.usedCap = ucap ;
		this.installedCap = icap ;
	}

	public void addMachine(UsedMachine machine) {
		machines.add(machine);
	}
	
	private int getOptimumInventory() {
		int currDem = getLastDemand();
		return (int) this.beta*currDem ;
	}
	
	private int getLastDemand() {
		return demand.get(demand.size()-1) ;
	}
	
	private int getLastProduction() {
		return production.get(production.size()-1) ;
	}
	
	public void setPrice(float price) {
		
		if(price == -1) {
			this.price = price ;
			this.demand.add((int) (this.income/this.price));
			this.inventory = getOptimumInventory();
		}
		else {
			// warning 
		}
	}
	
	public void planProduction() {
		
		this.eDemand = calculateExpectedDemand();
		this.dProduction = calculateDesiredProduction() ;
		this.price = calculatePrice();
		
		if(dProduction <= installedCap && dProduction <= usedCap) {
			fireWorkers();
		} 
		else {
			
			createJobOfferings();
			
			if(dProduction > installedCap && dProduction > usedCap) {
				calculateDesiredInvestment();
			}
			
		}
	}
	
	private int calculateExpectedDemand() {
		return demand.get(demand.size()-1); 
	}
	
	private int calculateDesiredProduction() {	
		return this.eDemand + getOptimumInventory() - this.inventory ;
	}
	
	private float calculatePrice() {
		return this.price + this.kappa*(getLastProduction() - getLastDemand());
	}
	
	public void fireWorkers() {
		
		Object obj = this ;
		Context<Object> context = ContextUtils.getContext(obj);
		
		if(context == null) {
			System.out.println("NULL");
		}
		else {
			System.out.println("NOT null");
		}
		
		/*Network<Agent> net = (Network<Agent>) context.getProjection("jobs");
		Iterable<Agent> workers = net.getAdjacent(this);
		ArrayList<EmployedConsumer> emps = new ArrayList<EmployedConsumer>();
		
		for(UsedMachine machine : machines) {
			ArrayList<EmployedConsumer> operators = machine.getOperators();
			emps.addAll(operators);
		}
		
		for(Agent worker : workers) {
			System.out.println(emps.contains((EmployedConsumer) worker));
		}*/
	}
	
	private void createJobOfferings() {
		
	}
	
	private void calculateDesiredInvestment() {
		
	}
	
	@Override 
	public String toString() {
		
		String strAgent = super.toString() ;
		Integer nMacs = this.machines.size() ;
		String[][] fields = { { "Number of Machines", nMacs.toString()} } ;
		
	    return strAgent + Utils.getAgentDescriptor(fields, false) ;
	}
	
	
}
